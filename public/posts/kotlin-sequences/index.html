<!doctype html>
<html lang="en">
  

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Liste - //localhost:1313/">
    <title>Kotlin Sequences | GurpreetSK.com</title>
    <meta name="description" content="Gurpreet&#39;s thoughts, experiences and learnings">
    <meta property="og:url" content="//localhost:1313/posts/kotlin-sequences/">
  <meta property="og:site_name" content="GurpreetSK.com">
  <meta property="og:title" content="Kotlin Sequences">
  <meta property="og:description" content="Transforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.
Along with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.
Sequences are a collection of possibly infinite data, ordered in a certain way. Sequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-03-10T02:23:11+05:30">
    <meta property="article:modified_time" content="2019-03-10T02:23:11+05:30">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Migrated-From-Medium">

    
  <meta itemprop="name" content="Kotlin Sequences">
  <meta itemprop="description" content="Transforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.
Along with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.
Sequences are a collection of possibly infinite data, ordered in a certain way. Sequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.">
  <meta itemprop="datePublished" content="2019-03-10T02:23:11+05:30">
  <meta itemprop="dateModified" content="2019-03-10T02:23:11+05:30">
  <meta itemprop="wordCount" content="1027">
  <meta itemprop="keywords" content="Android,Migrated-From-Medium">
    
    <link rel="canonical" href="//localhost:1313/posts/kotlin-sequences/">
    <link rel="icon" href="//localhost:1313//assets/favicon.ico">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link href="https://www.google-analytics.com" rel="preconnect" crossorigin>
    <link rel="alternate" type="application/atom+xml" title="GurpreetSK.com" href="//localhost:1313//atom.xml" />
    <link rel="alternate" type="application/json" title="GurpreetSK.com" href="//localhost:1313//feed.json" />
    <link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=">
    <link rel="stylesheet" href="/css/custom.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bricolage+Grotesque">
    
    
    <style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 bricolage grotesque,-apple-system,BlinkMacSystemFont,segoe ui,Helvetica,Arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;background:#fffdfa;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{margin:.1rem;border:none;overflow:visible;overflow-wrap:anywhere}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}.post-date{margin:5% 0}.index-date{color:#9a9a9a}.animate-blink{animation:opacity 1s infinite;opacity:1}@keyframes opacity{0%{opacity:1}50%{opacity:.5}100%{opacity:0}}.tags{display:flex;justify-content:space-between}.tags ul{padding:0;margin:0}.tags li{display:inline}.avatar{height:120px;width:120px;position:relative;margin:-10px 0 0 15px;float:right;border-radius:50%}table{width:100%;border-collapse:collapse}th,td{border:1px solid #ddd;text-align:left;padding:8px}th{background-color:#f2f2f2}li{font-family:inherit} </style>
  
    
  
  
  <script type="application/ld+json">
  {
      "@context": "http://schema.org",
      "@type": "BlogPosting",
      "articleSection": "posts",
      "name": "Kotlin Sequences",
      "headline": "Kotlin Sequences",
      "alternativeHeadline": "",
      "description": "\u003cp\u003eTransforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.\u003c\/p\u003e\n\u003cp\u003eAlong with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.\u003c\/p\u003e\n\u003ch3 id=\u0022sequences-are-a-collection-of-possibly-infinite-data-ordered-in-a-certain-way\u0022\u003e\u003cem\u003eSequences are a collection of possibly infinite data, ordered in a certain way.\u003c\/em\u003e\u003c\/h3\u003e\n\u003cp\u003eSequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.\u003c\/p\u003e",
      "inLanguage": "en-US",
      "isFamilyFriendly": "true",
      "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "\/\/localhost:1313\/posts\/kotlin-sequences\/"
      },
      "author" : {
          "@type": "Person",
          "name": "Gurpreet"
      },
      "creator" : {
          "@type": "Person",
          "name": "Gurpreet"
      },
      "accountablePerson" : {
          "@type": "Person",
          "name": "Gurpreet"
      },
      "copyrightHolder" : "GurpreetSK.com",
      "copyrightYear" : "2019",
      "dateCreated": "2019-03-10T02:23:11.00Z",
      "datePublished": "2019-03-10T02:23:11.00Z",
      "dateModified": "2019-03-10T02:23:11.00Z",
      "publisher":{
          "@type":"Organization",
          "name": "GurpreetSK.com",
          "url": "//localhost:1313/",
          "logo": {
              "@type": "ImageObject",
              "url": "\/\/localhost:1313\/assets\/favicon.ico",
              "width":"32",
              "height":"32"
          }
      },
      "image": "//localhost:1313/assets/favicon.ico",
      "url" : "\/\/localhost:1313\/posts\/kotlin-sequences\/",
      "wordCount" : "1027",
      "genre" : [ "android" , "migrated-from-medium" ],
      "keywords" : [ "android" , "migrated-from-medium" ]
  }
  </script>
  
  
  </head>

<body>
  <a class="skip-link" href="#main">Skip to main</a>
  <main id="main">
  <div class="content">
    <header>
<p style="padding: 0;margin: 0;">
  <a href="//localhost:1313/">
    <b>GurpreetSK.com</b>
    <span class="text-stone-500 animate-blink">▮</span>
  </a>
</p>
<ul style="padding: 0;margin: 0;">
  
  
  <li class="">
    <a href="/"><span>Home</span></a>
    
  <li class="">
    <a href="/about/"><span>About</span></a>
    
  <li class="">
    <a href="/posts/"><span>Posts</span></a>
    
  <li class="">
    <a href="/musings/"><span>Musings</span></a>
    
  </li>
</ul>
</header>
<hr class="hr-list" style="padding: 0;margin: 0;">
    <section>
      <h2 class="post">Kotlin Sequences</h2>
      <p>Transforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.</p>
<p>Along with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.</p>
<h3 id="sequences-are-a-collection-of-possibly-infinite-data-ordered-in-a-certain-way"><em>Sequences are a collection of possibly infinite data, ordered in a certain way.</em></h3>
<p>Sequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.</p>
<p>Looking at the source, it’s pretty clear that the Sequence interface is similar to Iterable in definition:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">public</span> <span style="color:#8839ef">interface</span> <span style="color:#df8e1d">Sequence</span>&lt;<span style="color:#8839ef">out</span> T&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#8839ef">operator</span> <span style="color:#8839ef">fun</span> <span style="color:#1e66f5">iterator</span>(): Iterator&lt;T&gt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8839ef">public</span> <span style="color:#8839ef">interface</span> <span style="color:#df8e1d">Iterable</span>&lt;<span style="color:#8839ef">out</span> T&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#8839ef">operator</span> <span style="color:#8839ef">fun</span> <span style="color:#1e66f5">iterator</span>(): Iterator&lt;T&gt;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Sequences maintain the same API as collections. The difference comes in the way they are implemented. Let’s take an example to understand.</p>
<p>Let’s suppose we have a list of customers, and each customer has a recorded unique id, first name, last name and age.</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">private</span> <span style="color:#8839ef">const</span> <span style="color:#8839ef">val</span> <span style="color:#fe640b">UNDEFINED</span> = -<span style="color:#fe640b">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8839ef">data</span> <span style="color:#8839ef">class</span> <span style="color:#df8e1d">Customer</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#8839ef">val</span> <span style="color:#fe640b">firstName</span>: String,
</span></span><span style="display:flex;"><span>    <span style="color:#8839ef">val</span> <span style="color:#fe640b">lastName</span>: String? = <span style="color:#8839ef">null</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#8839ef">val</span> <span style="color:#fe640b">age</span>: Int = UNDEFINED
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>Next, let’s define some data to demonstrate:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">private</span> <span style="color:#8839ef">fun</span> <span style="color:#1e66f5">getCustomers</span>(): List&lt;Customer&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#8839ef">return</span> listOf(
</span></span><span style="display:flex;"><span>      Customer(<span style="color:#40a02b">&#34;Ragunath&#34;</span>, <span style="color:#40a02b">&#34;Jawahar&#34;</span>, <span style="color:#fe640b">31</span>),
</span></span><span style="display:flex;"><span>      Customer(<span style="color:#40a02b">&#34;Dinesh&#34;</span>, <span style="color:#40a02b">&#34;Raja&#34;</span>, <span style="color:#fe640b">28</span>),
</span></span><span style="display:flex;"><span>      Customer(<span style="color:#40a02b">&#34;Donn&#34;</span>, <span style="color:#40a02b">&#34;Felker&#34;</span>, <span style="color:#fe640b">42</span>),
</span></span><span style="display:flex;"><span>      Customer(<span style="color:#40a02b">&#34;RMK&#34;</span>, <span style="color:#40a02b">&#34;&#34;</span>),
</span></span><span style="display:flex;"><span>      Customer(<span style="color:#40a02b">&#34;Omar&#34;</span>)
</span></span><span style="display:flex;"><span>  )
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we’re done with the basic setup, let’s define the problem statement. Let’s say we need to get the first names of all the customers whose age is not UNDEFINED and whose last name isn’t null. We can do this using the filter and map operators provided by the Collections API:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">fun</span> <span style="color:#1e66f5">main</span>(args: Array&lt;String&gt;) {
</span></span><span style="display:flex;"><span>  <span style="color:#8839ef">val</span> <span style="color:#fe640b">result</span> = getCustomers()
</span></span><span style="display:flex;"><span>      .filter { <span style="color:#8839ef">it</span>.lastName <span style="color:#04a5e5;font-weight:bold">!=</span> <span style="color:#8839ef">null</span> }
</span></span><span style="display:flex;"><span>      .filter { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">!=</span> UNDEFINED }
</span></span><span style="display:flex;"><span>      .find   { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">==</span> <span style="color:#fe640b">31</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  println(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we first filter the customers whose last name is null, then filter customers whose age is UNDEFINED. Finally, we map the remaining customers’ first name and collect them in a list. If you run the above example, the output would be as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>Customer(firstName=Ragunath, lastName=Jawahar, age=<span style="color:#fe640b">31</span>)
</span></span></code></pre></div><p>But what were the operations leading to this output? If we put an onEach operator after each operation and print the value input to the function, the output would be something on the lines of:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>filter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31)
</span></span><span style="display:flex;"><span>filter lastName: Customer(firstName=Dinesh, lastName=Raja, age=28)
</span></span><span style="display:flex;"><span>filter lastName: Customer(firstName=Donn, lastName=Felker, age=42)
</span></span><span style="display:flex;"><span>filter lastName: Customer(firstName=RMK, lastName=, age=0)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31)
</span></span><span style="display:flex;"><span>filter age: Customer(firstName=Dinesh, lastName=Raja, age=28)
</span></span><span style="display:flex;"><span>filter age: Customer(firstName=Donn, lastName=Felker, age=42)Customer(firstName=Ragunath, lastName=Jawahar, age=31)
</span></span></code></pre></div><p>The result above shows Eager evaluation. The filter operation is applied on the entire collection (input), and an intermediate collection is formed. This intermediate collection is then passed down the chain to the next filter, which repeats the process and passes another collection to the find function, which returns the result.</p>
<p>This approach has two drawbacks:</p>
<ol>
<li>Creation of varying number of intermediate collections, depending on the number of operations to be performed, and</li>
<li>Processing of all elements in the collection, even if it is not required.</li>
</ol>
<p>This hardly makes any difference in this tiny example, or even for any relatively larger use case for that matter (thanks to judicious use of inlined functions in stdlib and good garbage collection support by JVM),</p>
<p>But think about a case where the input data is in order of Millions, or virtually infinite? Wouldn’t it be nice if we could compute on data one after another, and bail as soon as the required condition is met?</p>
<p>This is exactly what sequences do! Here’s what the code above would look like when using sequences:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">fun</span> <span style="color:#1e66f5">main</span>(args: Array&lt;String&gt;) {
</span></span><span style="display:flex;"><span>  <span style="color:#8839ef">val</span> <span style="color:#fe640b">result</span> = getCustomers()
</span></span><span style="display:flex;"><span>      .asSequence() <span style="color:#9ca0b0;font-style:italic">// Creating a sequence
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>      .filter { <span style="color:#8839ef">it</span>.lastName <span style="color:#04a5e5;font-weight:bold">!=</span> <span style="color:#8839ef">null</span> }
</span></span><span style="display:flex;"><span>      .filter { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">!=</span> UNDEFINED }
</span></span><span style="display:flex;"><span>      .find   { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">==</span> <span style="color:#fe640b">31</span> } <span style="color:#9ca0b0;font-style:italic">// Terminal operation
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  println(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We create a sequence by wrapping the existing collection, and returning its elements when being iterated. If we apply the onEach function here and check the output, it’ll look like</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>filter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31)Customer(firstName=Ragunath, lastName=Jawahar, age=31)
</span></span></code></pre></div><p>Once a terminal operation is encountered, computations are carried out one after another, and as soon as a result is found, execution is stopped. This is why sequences are called lazy.</p>
<p>A visual comparison of how collections and sequences work can be:</p>
<p><img
  src="/assets/posts/kotlin-sequences-1.webp"
  alt="kotlin-sequences"
  loading="lazy"
  decoding="async"
  class="full-width"
/>

</p>
<hr>
<p>You might have noticed the term ‘Terminal’ operation. If we remove it, no computation will be carried out. This is because operations on a sequence are divided into two categories: Intermediate and Terminal.</p>
<p>Intermediate operations return a sequence which knows how to transform elements of the original sequence. These operations are always lazy, and are postponed until a terminal operation is performed. The terminal operation performs all the postponed operations and returns a some value as a result.</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>getCustomers()
</span></span><span style="display:flex;"><span>      .asSequence() <span style="color:#9ca0b0;font-style:italic">// Creating a sequence
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>      .filter { <span style="color:#8839ef">it</span>.lastName <span style="color:#04a5e5;font-weight:bold">!=</span> <span style="color:#8839ef">null</span> } <span style="color:#9ca0b0;font-style:italic">// Intermediate operation
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>      .filter { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">!=</span> UNDEFINED } <span style="color:#9ca0b0;font-style:italic">// Intermediate operation
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>      .find   { <span style="color:#8839ef">it</span>.age <span style="color:#04a5e5;font-weight:bold">==</span> <span style="color:#fe640b">31</span> } <span style="color:#9ca0b0;font-style:italic">// Terminal operation
</span></span></span></code></pre></div><hr>
<p>“Okay, this looks interesting. Let’s use sequences EVERYWHERE!”.</p>
<p>Nope. Please don’t.</p>
<p>As a rule of thumb, a sequence should be used at places where a chain of operations are being performed on a very large (or possibly infinite) collection of data, and/or there is a need to break out of the computation as soon as an element matching the predicate is found. As mentioned earlier, eager operations on regular collections are highly optimised and efficient in kotlin and should fare you well for most cases.</p>
<p>Another thing to remember is that the elements of a sequence cannot be accessed as simply as elements of a collection. For example, the following snippet will produce a compile-time error:</p>
<div class="highlight"><pre tabindex="0" style="color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#8839ef">fun</span> <span style="color:#1e66f5">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8839ef">val</span> <span style="color:#fe640b">sequence</span> = (<span style="color:#fe640b">1.</span>.<span style="color:#fe640b">10</span>)
</span></span><span style="display:flex;"><span>     .asSequence()
</span></span><span style="display:flex;"><span>     .map { <span style="color:#8839ef">it</span> * <span style="color:#fe640b">3</span> }    println(sequence[<span style="color:#fe640b">1</span>]) <span style="color:#9ca0b0;font-style:italic">// Error: Unresolved Reference. None of the                                              following candidate is applicable because of receiver type mismatch.
</span></span></span><span style="display:flex;"><span><span style="color:#9ca0b0;font-style:italic"></span>}
</span></span></code></pre></div><p>This is because the accessed element might not have been processed at all! (remember lazy evaluation for sequences?)</p>
<p>Hope this helps!</p>
<p><em>Originally posted on Medium 
<a href="https://medium.com/android-news/kotlin-sequences-ac6dc7c883d3" target="_blank" rel="noopener">link</a>

</em></p>

      
      <div class="post-date">
        <span class="g time">March 10, 2019 </span> &#8729;
         
         <a href="//localhost:1313/tags/android/">android</a> <a href="//localhost:1313/tags/migrated-from-medium/">migrated-from-medium</a>
      </div>
      
    </section>
    
    
    
  </div>
</main>
</body>
</html>
