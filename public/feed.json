{
  "version": "https://jsonfeed.org/version/1",
  "title": "Gurpreet's thoughts",
  "home_page_url": "https://imGurpreetSK.github.io/",
  "feed_url": "https://imGurpreetSK.github.io/feed.json",
  "description": "Gurpreet's thoughts, experiences and learnings",
  "favicon": "https://imGurpreetSK.github.io//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "Gurpreet",
    "url": "https://imGurpreetSK.github.io/"
  },
  "items": [
    
    

    
    {
      "id": "52a02b5f9f8e7fe1fdd9eda4da468088bc0417da",
      "title": "KotlinConf 2025",
      "summary": "",
      "content_text": "This year, I finally had the chance to attend KotlinConf in Copenhagen—a conference I’ve wanted to experience for a long time. It was also my first time visiting Copenhagen and exploring Europe, which made the trip even more memorable. The week was powered by plenty of falafels, chocolate, and coffee. (On the flip side, I had the worst pizza of my life—definitely not what I expected from Europe!)\nExciting Announcements KotlinConf 2025 was packed with exciting updates for the Kotlin community. I’m especially looking forward to new language features like rich errors, name-based destructuring, and context receivers. The introduction of Junie and Koog also caught my attention—they both look promising for future projects. Another big highlight: CMP for iOS is now stable! 🎉\nIf you missed the event, you can find all the talk videos here.\nMy KotlinConf Experience Day 0: Registration The first day was all about getting settled in, picking up my badge, and soaking in the excitement of being surrounded by fellow Kotlin enthusiasts.\nDay 1: Meeting the Community Day one was a whirlwind of meeting amazing Android and Kotlin engineers. It was refreshing to have real conversations in person, rather than just chatting online. Some highlights:\nMeeting Urs Peter: Urs has a way of explaining things that makes even complex topics easy to understand. I could listen to him talk for hours. Dan’s Talk: Dan’s session was insightful and definitely one of the must-see talks of the conference. Chris Horner’s Session: Chris gave a fantastic talk on building fully custom UIs with Compose. It was both practical and inspiring. Catching Up with Seb: Always a pleasure to meet Seb and exchange ideas. Day 2: More Great Talks On the second day, Ralf’s talk stood out for me. His insights and presentation style made it one of the highlights of the conference.\nFinal Thoughts There were a few people I didn’t get a chance to say hi to, which I regret—but there’s always next time. For now, I’m off to find some more falafel and reflect on an inspiring week.\nTill next time!\n",
      "content_html": "\u003cp\u003eThis year, I finally had the chance to attend KotlinConf in Copenhagen—a conference I’ve wanted to experience for a long time. It was also my first time visiting Copenhagen and exploring Europe, which made the trip even more memorable. The week was powered by plenty of falafels, chocolate, and coffee. (On the flip side, I had the worst pizza of my life—definitely not what I expected from Europe!)\u003c/p\u003e\n\u003ch2 id=\"exciting-announcements\"\u003eExciting Announcements\u003c/h2\u003e\n\u003cp\u003eKotlinConf 2025 was packed with exciting updates for the Kotlin community. I’m especially looking forward to new language features like rich errors, name-based destructuring, and context receivers. The introduction of Junie and \n\n\n\u003ca href=\"https://github.com/JetBrains/koog/\" target=\"_blank\" rel=\"noopener\"\u003eKoog\u003c/a\u003e also caught my attention—they both look promising for future projects. Another big highlight: CMP for iOS is now stable! 🎉\u003c/p\u003e\n\u003cp\u003eIf you missed the event, you can find all the talk videos \n\n\n\u003ca href=\"https://www.youtube.com/@Kotlin/playlists\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"my-kotlinconf-experience\"\u003eMy KotlinConf Experience\u003c/h2\u003e\n\u003ch3 id=\"day-0-registration\"\u003eDay 0: Registration\u003c/h3\u003e\n\u003cp\u003eThe first day was all about getting settled in, picking up my badge, and soaking in the excitement of being surrounded by fellow Kotlin enthusiasts.\u003c/p\u003e\n\u003ch3 id=\"day-1-meeting-the-community\"\u003eDay 1: Meeting the Community\u003c/h3\u003e\n\u003cp\u003eDay one was a whirlwind of meeting amazing Android and Kotlin engineers. It was refreshing to have real conversations in person, rather than just chatting online. Some highlights:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMeeting Urs Peter:\u003c/strong\u003e Urs has a way of explaining things that makes even complex topics easy to understand. I could listen to him talk for hours.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDan’s Talk:\u003c/strong\u003e Dan’s session was insightful and definitely one of the must-see talks of the conference.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eChris Horner’s Session:\u003c/strong\u003e Chris gave a fantastic talk on building fully custom UIs with Compose. It was both practical and inspiring.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCatching Up with Seb:\u003c/strong\u003e Always a pleasure to meet Seb and exchange ideas.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"day-2-more-great-talks\"\u003eDay 2: More Great Talks\u003c/h3\u003e\n\u003cp\u003eOn the second day, Ralf’s talk stood out for me. His insights and presentation style made it one of the highlights of the conference.\u003c/p\u003e\n\u003ch2 id=\"final-thoughts\"\u003eFinal Thoughts\u003c/h2\u003e\n\u003cp\u003eThere were a few people I didn’t get a chance to say hi to, which I regret—but there’s always next time. For now, I’m off to find some more falafel and reflect on an inspiring week.\u003c/p\u003e\n\u003cp\u003eTill next time!\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlinconf-2025/",
      "date_published": "2066-02-09T647:22:00-07:00",
      "date_modified": "2066-02-09T647:22:00-07:00",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "cfbe473165118f985abf8895a4dfa5cd96fc2347",
      "title": "Maybe, set LayoutParams of view to be inflated in Compose UI's AndroidView",
      "summary": "",
      "content_text": "I spent half of my day today figuring out why a WebView does not properly load menu on a web page properly while all the other functionality seems to be working as expected. The screen was written in Compose UI and employed AndroidView to compose an Android WebView.\nTurns out, I missed that LayoutParams need to be set for the WebView provided via the factory block; just modifying AndroidView to fill max available size won’t work as expected.\nWriting this so I do not waste more time in the future again, and so this can help any other poor soul pulling his/her hair, trying to figure out why their WebView isn’t working as expected.\nAndroidView( factory = { context -\u0026gt; WebView(context).apply { layoutParams = ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) with(settings) { // Your webview settings. } loadUrl(url) } }, modifier = Modifier .fillMaxSize() .padding(padding) ) ",
      "content_html": "\u003cp\u003eI spent half of my day today figuring out why a \u003ccode\u003eWebView\u003c/code\u003e does not properly load menu on a web page properly while all the other functionality seems to be working as expected. The screen was written in Compose UI and employed \u003ccode\u003eAndroidView\u003c/code\u003e to compose an Android \u003ccode\u003eWebView\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTurns out, I missed that \u003ccode\u003eLayoutParams\u003c/code\u003e need to be set for the \u003ccode\u003eWebView\u003c/code\u003e provided via the factory block; just modifying \u003ccode\u003eAndroidView\u003c/code\u003e to fill max available size won’t work as expected.\u003c/p\u003e\n\u003cp\u003eWriting this so I do not waste more time in the future again, and so this can help any other poor soul pulling his/her hair, trying to figure out why their \u003ccode\u003eWebView\u003c/code\u003e isn’t working as expected.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    AndroidView(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        factory = { context \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e-\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            WebView(context).apply {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                layoutParams = \u003cspan style=\"color:#df8e1d\"\u003eViewGroup\u003c/span\u003e.LayoutParams(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#df8e1d\"\u003eViewGroup\u003c/span\u003e.\u003cspan style=\"color:#df8e1d\"\u003eLayoutParams\u003c/span\u003e.MATCH_PARENT,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#df8e1d\"\u003eViewGroup\u003c/span\u003e.\u003cspan style=\"color:#df8e1d\"\u003eLayoutParams\u003c/span\u003e.MATCH_PARENT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                with(settings) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Your webview settings.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e                }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                loadUrl(url)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        modifier = Modifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            .fillMaxSize()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            .padding(padding)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e",
      "url": "https://imGurpreetSK.github.io/posts/why-you-should-be-setting-layout-params-of-android-views-inflated-in-compose-ui-androidview/",
      "date_published": "7026-07-09T251:77:00-08:00",
      "date_modified": "7026-07-09T251:77:00-08:00",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "c09edcad5e6bf3cefb96f733b214ca371fb19863",
      "title": "On software being like gardening",
      "summary": "",
      "content_text": "Link to Product leader John Cutler’s published article about software maintenance suggesting that software is more like gardening than car maintenance, quoted from Pragmatic Engineer’s paid article Bug management that works, Pt 1:\nI\u0026rsquo;ve always been bothered by how teams use words and phrases like maintenance, keeping the lights on (KTLO), and business as usual. I get what they mean, but there always seems to be a stigma around this work.\nWhen we maintain a car—oil changes, tire rotations, etc.—we aim to keep the car running smoothly and safely. When we maintain a car, we don\u0026rsquo;t normally fix bugs, apply patches, optimize performance, check for compatibility, remove features, refactor, and incorporate user feedback. Why? Car maintenance revolves around physical wear and tear, degradation of materials over time, and the occasional replacement of parts with a limited lifespan. These actions don\u0026rsquo;t \u0026ldquo;fix\u0026rdquo; or \u0026ldquo;improve\u0026rdquo; the car but rather preserve its current state and prolong its effective lifespan.\nIn a sense, software is much more like a garden than a mechanical entity like a car. We plant the initial seeds (start designing and building), water and nurture it (make updates and enhance features), and periodically have to prune (refactor) and weed (remove bugs and vulnerabilities). A product requires constant attention to grow and adapt to its environment (user needs, technological changes, and market trends). It\u0026rsquo;s an ongoing process of growth, adaptation, and care.\nApplicable concepts: seeding, sowing, weeding, watering, pruning, cultivation, composting, harvesting, hardening off, propagating, rotating, aeration, grafting, trellising, thinning, etc.\nHaving working in software with teams of different sizes, this comparison makes a lot of sense to me not only for maintenance but also how good software is written.\n",
      "content_html": "\u003cp\u003eLink to Product leader John Cutler’s \n\n\n\u003ca href=\"https://cutlefish.substack.com/p/tbm-234-maintenance-ktlo-and-bau\" target=\"_blank\" rel=\"noopener\"\u003epublished article\u003c/a\u003e \n\n\n\u003ca href=\"https://cutlefish.substack.com/p/tbm-234-maintenance-ktlo-and-bau\" target=\"_blank\" rel=\"noopener\"\u003eabout software maintenance\u003c/a\u003e suggesting that software is more like gardening than car maintenance, quoted from Pragmatic Engineer’s paid article \n\n\n\u003ca href=\"https://newsletter.pragmaticengineer.com/p/bug-management-that-works-part-1\" target=\"_blank\" rel=\"noopener\"\u003eBug management that works, Pt 1\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI\u0026rsquo;ve always been bothered by how teams use words and phrases like maintenance, keeping the lights on (KTLO), and business as usual. I get what they mean, but there always seems to be a stigma around this work.\u003c/p\u003e\n\u003cp\u003eWhen we maintain a car—oil changes, tire rotations, etc.—we aim to keep the car running smoothly and safely. When we maintain a car, we don\u0026rsquo;t normally fix bugs, apply patches, optimize performance, check for compatibility, remove features, refactor, and incorporate user feedback. Why? Car maintenance revolves around physical wear and tear, degradation of materials over time, and the occasional replacement of parts with a limited lifespan. These actions don\u0026rsquo;t \u0026ldquo;fix\u0026rdquo; or \u0026ldquo;improve\u0026rdquo; the car but rather preserve its current state and prolong its effective lifespan.\u003c/p\u003e\n\u003cp\u003eIn a sense, software is much more like a garden than a mechanical entity like a car. We plant the initial seeds (start designing and building), water and nurture it (make updates\nand enhance features), and periodically have to prune (refactor) and weed (remove bugs and vulnerabilities). A product requires constant attention to grow and adapt to its environment (user needs, technological changes, and market trends). It\u0026rsquo;s an ongoing process of growth, adaptation, and care.\u003c/p\u003e\n\u003cp\u003eApplicable concepts: seeding, sowing, weeding, watering, pruning, cultivation, composting, harvesting, hardening off, propagating, rotating, aeration, grafting, trellising, thinning, etc.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eHaving working in software with teams of different sizes, this comparison makes a lot of sense to me not only for maintenance but also how good software is written.\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/on-software-being-like-gardening/",
      "date_published": "2106-02-09T1051:22:00-08:00",
      "date_modified": "2106-02-09T1051:22:00-08:00",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "f081f658b999f0e56d301eda489ea76a89f6a827",
      "title": "Kotlinx Serialization - How the serialization process works",
      "summary": "",
      "content_text": "\nNow that we know the basic concepts of kotlin serialization and have also seen how to use it to serialize and deserialize data, let’s talk a bit about the library’s internal working and some of the important concepts.\nNote: If you haven’t gone through the previous posts, you should take a look at those first.\nThe entire process of serialization is composed of two separate sub-processes:\nSerialization Encoding Each of these processes has a single responsibility, which enables clear separation of roles and allows both to operate independently. This is the reason behind the extensibility and flexibility of the library. Please note that despite being independent, these operations are still sequential— encoding always takes place after serialization.\nSerialization process Deserialization process Serialization is the process of decomposing the input entity into a stream of primitive elements — characters, ints, booleans and so on — so that they can be ‘encoded’ by the encoder. This process can be recursive, meaning that any complex entities inside the input will be further broken into primitive elements. The process is considered completed once all of the input is converted to a stream of primitive elements, and there are no more complex entities remaining.\nEncoding is the part where the input is actually processed. The stream of primitives generated by the serialization process are fed to the encoder as an input. The encoder’s action can be conversion to another desired format, storing, processing or transforming the data into some other format, or something else based on one’s requirements.\nWe’ll know more about Encoding in a later post, for now let’s focus our energies on the first part of the process — Serialization.\nRemember the User object which we used to understand the basics in the introductory blog post? We’re going to use that to look into the workings of plugin and runtime.\n@Serializable data class User(val name: String) Whenever we call User.serialize(), we obtain an object of type KSerializer. Let’s look into the generated code to know how things are structured and get a high level understanding of what’s going on inside, because Hey! code never lies :)\nI’d highly suggest you to open up your IDE, paste the above code in a scratch file (if you don’t have it already) and decompile it to Java code by going to Tools \u0026gt; Kotlin \u0026gt; Show Kotlin Bytecode and then clicking on Decompile.\nIf you’ve ever inspected or played around with generated code for data classes before, you’d notice some similar code along with quite a lot of extra code. This code is generated by the @Serializable annotation, and mainly includes\nA synthetic, deprecated and inaccessible constructor A nested static class $serializer, also deprecated and inaccessible The role of the constructor is to initialise the properties of the data class. Now, as this constructor is hidden, it must be used internally in the same class. If we look closely, the constructor is used during deserialization of data to create the class object, in our case a User object.\nThe $serializer class is what contains all the logic for the serialization process. This generated class implements an interface called GeneratedSerializer, which in-turn implements the KSerializer interface and overrides a number of methods. KSerializer governs the serialization and deserialization process for an object by defining strategies for serialization and deserialization — SerializationStrategy \u0026amp; DeserializationStrategy. These are responsible for defining how the actual serialization and deserialization of an object work. The interface also defines an object of type SerialDescriptor, which contains metadata related to the object and describes internal structure of data to be transformed.\nIf we look back at the generated class $serializer, we see a SerialDescriptor object, along with two methods which use this object:\nserialize() — This method is defined in SerializationStrategy interface and its implementation describes the actual serialization process. It receives the value to be encoded and dispatches one or multiple commands to the Encoder to transform the value. deserialize() — This method is defined in DeserializationStrategy interface and its implementation describes the actual deserialization process. It receives the value to be decoded and dispatches one or multiple commands to the Decoder to transform the value. The major implementation difference is that unlike serialize(), this method needs to handle values coming in an arbitrary order so that values are bound to the desired properties. Both the Encoder/Decoder expose only structural methods to the external world, while encapsulating the internal implementation of the format the data is being serialized to.\nHope this was helpful and you learnt something new. If you haven’t gone through the previous posts, you should take a look at those.\nHope it helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cbr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/banner-kotlin-mobile.webp\"\n  alt=\"Header\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eNow that we know the basic concepts of kotlin serialization and have also seen how to use it to serialize and deserialize data, let’s talk a bit about the library’s internal working and some of the important concepts.\u003c/p\u003e\n\u003cp\u003eNote: If you haven’t gone through the previous posts, you should take a look at those first.\u003c/p\u003e\n\u003cp\u003eThe entire process of serialization is composed of two separate sub-processes:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSerialization\u003c/li\u003e\n\u003cli\u003eEncoding\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEach of these processes has a single responsibility, which enables clear separation of roles and allows both to operate independently. This is the reason behind the extensibility and flexibility of the library. Please note that despite being independent, these operations are still sequential— encoding always takes place after serialization.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/serialization-process.webp\"\n  alt=\"serializaton process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cdiv style=\"text-align:center;\"\u003eSerialization process\u003c/div\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/deserialization-process.webp\"\n  alt=\"deserializaton process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cdiv style=\"text-align:center;\"\u003eDeserialization process\u003c/div\u003e\n\u003cp\u003eSerialization is the process of decomposing the input entity into a stream of primitive elements — characters, ints, booleans and so on — so that they can be ‘encoded’ by the encoder. This process can be recursive, meaning that any complex entities inside the input will be further broken into primitive elements. The process is considered completed once all of the input is converted to a stream of primitive elements, and there are no more complex entities remaining.\u003c/p\u003e\n\u003cp\u003eEncoding is the part where the input is actually processed. The stream of primitives generated by the serialization process are fed to the encoder as an input. The encoder’s action can be conversion to another desired format, storing, processing or transforming the data into some other format, or something else based on one’s requirements.\u003c/p\u003e\n\u003cp\u003eWe’ll know more about Encoding in a later post, for now let’s focus our energies on the first part of the process — Serialization.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eRemember the User object which we used to understand the basics in the \n\n\n\n  \u003ca href=\"/posts/kotlin-serialization-getting-started\"\u003eintroductory blog post\u003c/a\u003e? We’re going to use that to look into the workings of plugin and runtime.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#1e66f5;font-weight:bold\"\u003e@Serializable\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e(\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003ename\u003c/span\u003e: String)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhenever we call User.serialize(), we obtain an object of type KSerializer. Let’s look into the generated code to know how things are structured and get a high level understanding of what’s going on inside, because Hey! code never lies :)\u003c/p\u003e\n\u003cp\u003eI’d highly suggest you to open up your IDE, paste the above code in a scratch file (if you don’t have it already) and decompile it to Java code by going to \u003cem\u003eTools \u0026gt; Kotlin \u0026gt; Show Kotlin Bytecode\u003c/em\u003e and then clicking on \u003cem\u003eDecompile\u003c/em\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eIf you’ve ever inspected or played around with generated code for data classes before, you’d notice some similar code along with quite a lot of extra code. This code is generated by the @Serializable annotation, and mainly includes\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA synthetic, deprecated and inaccessible constructor\u003c/li\u003e\n\u003cli\u003eA nested static class $serializer, also deprecated and inaccessible\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe role of the constructor is to initialise the properties of the data class. Now, as this constructor is hidden, it must be used internally in the same class. If we look closely, the constructor is used during deserialization of data to create the class object, in our case a User object.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e$serializer\u003c/code\u003e class is what contains all the logic for the serialization process. This generated class implements an interface called GeneratedSerializer, which in-turn implements the KSerializer interface and overrides a number of methods. KSerializer governs the serialization and deserialization process for an object by defining strategies for serialization and deserialization — SerializationStrategy \u0026amp; DeserializationStrategy. These are responsible for defining how the actual serialization and deserialization of an object work. The interface also defines an object of type \n\n\n\u003ca href=\"https://github.com/Kotlin/KEEP/blob/serialization/proposals/extensions/serialization.md#descriptor-of-a-serializable-entity\" target=\"_blank\" rel=\"noopener\"\u003eSerialDescriptor\u003c/a\u003e, which contains metadata related to the object and describes internal structure of data to be transformed.\u003c/p\u003e\n\u003cp\u003eIf we look back at the generated class $serializer, we see a SerialDescriptor object, along with two methods which use this object:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eserialize() — This method is defined in SerializationStrategy interface and its implementation describes the actual serialization process. It receives the value to be encoded and dispatches one or multiple commands to the Encoder to transform the value.\u003c/li\u003e\n\u003cli\u003edeserialize() — This method is defined in DeserializationStrategy interface and its implementation describes the actual deserialization process. It receives the value to be decoded and dispatches one or multiple commands to the Decoder to transform the value. The major implementation difference is that unlike serialize(), this method needs to handle values coming in an arbitrary order so that values are bound to the desired properties.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBoth the Encoder/Decoder expose only structural methods to the external world, while encapsulating the internal implementation of the format the data is being serialized to.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eHope this was helpful and you learnt something new. If you haven’t gone through the \n\n\n\n      \n    \n  \u003ca href=\"/tags/kotlinx-serialization/\"\u003eprevious posts\u003c/a\u003e, you should take a look at those.\u003c/p\u003e\n\u003cp\u003eHope it helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/kotlin-serialization-optional-and-transient-properties-b3da3247e112\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlinx-serialization-process-working/",
      "date_published": "13066-13-09T623:1313:00+05:30",
      "date_modified": "13066-13-09T623:1313:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "08bc92f86ec52f3b10ef3c5b4831b7283ad4dcd5",
      "title": "Kotlinx Serialization - JsonConfiguration",
      "summary": "",
      "content_text": "\nIn the previous posts we learned about the basics of kotlin serialization. We instantiated a Json object, passing it a configuration and used it to perform serialization and deserialization operations. This post is about that configuration, called JsonConfiguration — why is it required and what role does it play in the process.\nThe JsonConfiguration class is provided by the serialization runtime library and allows us to customise JSON behaviour as per our requirements. It is a simple data class with various properties and two out-of-the-box configurations:\nStable — adheres to the JSON specification restrictions (RFC-4627) and is guaranteed to preserve its semantics between library releases. Default — This configuration is what the library recommends for JSON format. It is not guaranteed to preserve its semantics and might change as the runtime library evolves until it hits a version 1.0.0. Being a data class, you can also copy either of these configurations and make changes as per your requirements, or create a configuration from scratch if that suits your use-case better.\nCustomisable properties\nFollowing are the various available options for JSON-specific behaviour customisation (along with certain examples):\n1. encodeDefaults Denotes whether the serialized JSON contains properties with default values or not.\n2. ignoreUnknownKeys If false, any unknown properties in JSON will cause the deserialization to fail. This flag is true by default in stable configuration, however it’s a wise choice to keep it false to maintain backward compatibility while interacting with frequently changing objects or external APIs.\n3. isLenient If set to true, removes JSON specification restrictions and allows parsing of malformed JSON objects. In following example, notice how the input JSON is unquoted, yet the parsing succeeds. However, the parsing will still fail if any string values has spaces or delimiters.\n4. serializeSpecialFloatingPointValues As the name suggests, allows serialization of special floating point values in the JSON. These values are Infinity, -Infinity and NaN. As a note, you should give a thought why these values are required to be parse at first place.\n5. unquotedPrint If true, the output JSON does not have quoted strings. This option is not recommended to be used except for rare debugging purposes as the parsed JSON is invalid. If any of the values in deserialized output has a string with spaces or delimiters, it will always be quoted.\n6. prettyPrint If set to true, the output JSON will be pretty-printed.\n7. indents Specifies the indent to use while parsing and pretty-printing JSON. Pretty printing has to be enabled while providing a custom indent, else the serialization will fail with an IllegalArgumentException. The next few properties we’ll talk about allow transformation of JSON from one form to another to support certain features which might be legacy or unsupported by default.\n8. allowStructuredMapKeys In JSON, only primitives can be used as keys. The serialization will fail with the following error if we have some non-primitive type representing a key in the object to be parsed.\nValue of type \u0026#39;kotlin.collections.LinkedHashMap\u0026#39; can\u0026#39;t be used in JSON as a key in the map. It should have either primitive or enum kind, but its kind is \u0026#39;MAP.\u0026#39; If you need to serialize a JSON with say a map as a key, you can enable allowStructuredMapKeys flag. This will transform the serialized JSON from a map of key-value pair to a flat list of keys and values.\n9. useArrayPolymorphism This flag works only if you’re performing polymorphic serialization ( this article and the class docs do a really good job of explaining what polymorphic serialization is). This flag causes the serialized JSON to be produced in the legacy array format instead of the object format.\nIf array polymorphism is not used, the following JSON is obtained:\n[{\u0026#34;type\u0026#34;:\u0026#34;Dog\u0026#34;,\u0026#34;lovesTreats\u0026#34;:true},{\u0026#34;type\u0026#34;:\u0026#34;Cat\u0026#34;,\u0026#34;lovesSleeping\u0026#34;:true}] The ‘type’ in above JSON is called the class discriminator, and can be customised too!\n10. classDiscriminator Use this property to give a custom name to the JSON property describing the class. In the above example, if we pass classDiscriminator=”class” to the JsonConfiguration, the following JSON would be obtained\n[{\u0026#34;class\u0026#34;:\u0026#34;Dog\u0026#34;,\u0026#34;lovesTreats\u0026#34;:true},{\u0026#34;class\u0026#34;:\u0026#34;Cat\u0026#34;,\u0026#34;lovesSleeping\u0026#34;:true}] Hope this was helpful and you learnt something new. If you haven’t gone through the previous posts, you should take a look at those:\nGetting started with Kotlin Serialization Kotlin serialization — Optional and Transient properties This article is third in a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned and keep learning!\nHope it helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cbr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/banner-kotlin-mobile.webp\"\n  alt=\"Header\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eIn the previous posts we learned about the basics of kotlin serialization. We instantiated a Json object, passing it a configuration and used it to perform serialization and deserialization operations. This post is about that configuration, called JsonConfiguration — why is it required and what role does it play in the process.\u003c/p\u003e\n\u003cp\u003eThe JsonConfiguration class is provided by the serialization runtime library and allows us to customise JSON behaviour as per our requirements. It is a simple data class with various properties and two out-of-the-box configurations:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStable — adheres to the \n\n\n\u003ca href=\"https://datatracker.ietf.org/doc/html/rfc4627\" target=\"_blank\" rel=\"noopener\"\u003eJSON specification restrictions (RFC-4627)\u003c/a\u003e and is guaranteed to preserve its semantics between library releases.\u003c/li\u003e\n\u003cli\u003eDefault — This configuration is what the library recommends for JSON format. It is not guaranteed to preserve its semantics and might change as the runtime library evolves until it hits a version 1.0.0.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBeing a data class, you can also copy either of these configurations and make changes as per your requirements, or create a configuration from scratch if that suits your use-case better.\u003c/p\u003e\n\u003cp\u003eCustomisable properties\u003c/p\u003e\n\u003cp\u003eFollowing are the various available options for JSON-specific behaviour customisation (along with certain examples):\u003c/p\u003e\n\u003ch4 id=\"1-encodedefaults\"\u003e1. encodeDefaults\u003c/h4\u003e\n\u003cp\u003eDenotes whether the serialized JSON contains properties with default values or not.\u003c/p\u003e\n\u003ch4 id=\"2-ignoreunknownkeys\"\u003e2. ignoreUnknownKeys\u003c/h4\u003e\n\u003cp\u003eIf false, any unknown properties in JSON will cause the deserialization to fail. This flag is true by default in stable configuration, however it’s a wise choice to keep it false to maintain backward compatibility while interacting with frequently changing objects or external APIs.\u003c/p\u003e\n\u003ch4 id=\"3-islenient\"\u003e3. isLenient\u003c/h4\u003e\n\u003cp\u003eIf set to true, removes JSON specification restrictions and allows parsing of malformed JSON objects. In following example, notice how the input JSON is unquoted, yet the parsing succeeds.\nHowever, the parsing will still fail if any string values has spaces or delimiters.\u003c/p\u003e\n\u003ch4 id=\"4-serializespecialfloatingpointvalues\"\u003e4. serializeSpecialFloatingPointValues\u003c/h4\u003e\n\u003cp\u003eAs the name suggests, allows serialization of special floating point values in the JSON. These values are Infinity, -Infinity and NaN. As a note, you should give a thought why these values are required to be parse at first place.\u003c/p\u003e\n\u003ch4 id=\"5-unquotedprint\"\u003e5. unquotedPrint\u003c/h4\u003e\n\u003cp\u003eIf true, the output JSON does not have quoted strings. This option is not recommended to be used except for rare debugging purposes as the parsed JSON is invalid.\nIf any of the values in deserialized output has a string with spaces or delimiters, it will always be quoted.\u003c/p\u003e\n\u003ch4 id=\"6-prettyprint\"\u003e6. prettyPrint\u003c/h4\u003e\n\u003cp\u003eIf set to true, the output JSON will be pretty-printed.\u003c/p\u003e\n\u003ch4 id=\"7-indents\"\u003e7. indents\u003c/h4\u003e\n\u003cp\u003eSpecifies the indent to use while parsing and pretty-printing JSON. Pretty printing has to be enabled while providing a custom indent, else the serialization will fail with an IllegalArgumentException.\nThe next few properties we’ll talk about allow transformation of JSON from one form to another to support certain features which might be legacy or unsupported by default.\u003c/p\u003e\n\u003ch4 id=\"8-allowstructuredmapkeys\"\u003e8. allowStructuredMapKeys\u003c/h4\u003e\n\u003cp\u003eIn JSON, only primitives can be used as keys. The serialization will fail with the following error if we have some non-primitive type representing a key in the object to be parsed.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Value of type \u003cspan style=\"color:#40a02b\"\u003e\u0026#39;kotlin.collections.LinkedHashMap\u0026#39;\u003c/span\u003e can\u003cspan style=\"color:#40a02b\"\u003e\u0026#39;t be used in JSON as a key in the map.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    It should have either primitive \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003eor\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eenum\u003c/span\u003e kind, but its kind is \u003cspan style=\"color:#40a02b\"\u003e\u0026#39;MAP.\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you need to serialize a JSON with say a map as a key, you can enable allowStructuredMapKeys flag. This will transform the serialized JSON from a map of key-value pair to a flat list of keys and values.\u003c/p\u003e\n\u003ch4 id=\"9-usearraypolymorphism\"\u003e9. useArrayPolymorphism\u003c/h4\u003e\n\u003cp\u003eThis flag works only if you’re performing polymorphic serialization (\n\n\n\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md#multiplatform-polymorphic-serialization\" target=\"_blank\" rel=\"noopener\"\u003ethis article\u003c/a\u003e and the \n\n\n\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/runtime/commonMain/src/kotlinx/serialization/Polymorphic.kt#L23\" target=\"_blank\" rel=\"noopener\"\u003eclass docs\u003c/a\u003e do a really good job of explaining what polymorphic serialization is). This flag causes the serialized JSON to be produced in the legacy array format instead of the object format.\u003c/p\u003e\n\u003cp\u003eIf array polymorphism is not used, the following JSON is obtained:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[{\u0026#34;type\u0026#34;:\u0026#34;Dog\u0026#34;,\u0026#34;lovesTreats\u0026#34;:true},{\u0026#34;type\u0026#34;:\u0026#34;Cat\u0026#34;,\u0026#34;lovesSleeping\u0026#34;:true}]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe ‘type’ in above JSON is called the class discriminator, and can be customised too!\u003c/p\u003e\n\u003ch4 id=\"10-classdiscriminator\"\u003e10. classDiscriminator\u003c/h4\u003e\n\u003cp\u003eUse this property to give a custom name to the JSON property describing the class. In the above example, if we pass classDiscriminator=”class” to the JsonConfiguration, the following JSON would be obtained\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[{\u0026#34;class\u0026#34;:\u0026#34;Dog\u0026#34;,\u0026#34;lovesTreats\u0026#34;:true},{\u0026#34;class\u0026#34;:\u0026#34;Cat\u0026#34;,\u0026#34;lovesSleeping\u0026#34;:true}]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003cp\u003eHope this was helpful and you learnt something new. If you haven’t gone through the previous posts, you should take a look at those:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\n\n\n      \n    \n  \u003ca href=\"/posts/kotlinx-serialization-getting-started/\"\u003eGetting started with Kotlin Serialization\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n      \n    \n  \u003ca href=\"/posts/kotlinx-serialization-optional-and-transient-properties/\"\u003eKotlin serialization — Optional and Transient properties\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis article is third in a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned and keep learning!\u003c/p\u003e\n\u003cp\u003eHope it helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/kotlin-serialization-optional-and-transient-properties-b3da3247e112\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlinx-serialization-jsonconfiguration/",
      "date_published": "13056-13-09T523:1313:00+05:30",
      "date_modified": "13056-13-09T523:1313:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "f0b37dfb9ac7fb983ca3930fa640a2bf347d91cd",
      "title": "Kotlinx Serialization - Getting Started",
      "summary": "",
      "content_text": "\nKotlin serialization is kotlin-first, compile-time, type-safe, reflection-free and completely multi-platform ready serialization mechanism to convert kotlin objects into data formats like JSON or Protobuf and vice-versa. It is comprised of a compiler plugin which is used to generate code for serializable classes and a runtime library, containing core classes and primitives for serialization \u0026amp; IO, among some other things.\nKotlinx serialization runtime project structure While JSON format is supported out of the box by the library, there’s first-class support for other formats like Protobuf \u0026amp; CBOR, with the option to extend the functionality by writing your own library to support any other format.\nThe effort was first announced in October 2016, where @elizarov posted about the team’s efforts on “working on a generic Kotlin Serialization facility for some future release of Kotlin”. You can know more about the design, goals and core concepts of kotlin serialization by going through this KEEP.\nWhy? Code sharing between platforms isn’t easy. Each platform you want to support has different ways of handling different things — IO, transformations, threading, serialization to name a few. There already are various libraries out there which support kotlin serialization, even generate kotlin code if you want to, Square’s Moshi being probably being the most famous one.\nHowever, all of these work only on JVM and don’t support other platforms. That’s why a new mechanism is required — one that supports all the platforms.\nSetup Please refer to the official guide to setup. It’s simple, all you’ll need to do is :\nApply the serialization plugin, and\nAdd dependency on the runtime library in your build.gradle file.\nYou’ll need to be on Kotlin version 1.3.70 or higher to use runtime library version 0.20.0, which is the latest release at time of writing this article.\nLearning by examples (You can see all these examples as a series of unit tests here in this gist.)\nLet’s go through some of the basic cases you’re likely to encounter if you plan on using kotlin serialization in one of your projects.\n1. Parse JSON object to Kotlin object Suppose you want to convert a JSON object to a kotlin object. For this, you’ll need to specify two things:\nThe object to which you’re trying to parse the JSON to, and The behaviour of the JSON format you’re trying to parse Let’s say we want to parse JSON containing user’s information — just his name for now. The JSON looks like {“name”: “Gurpreet”}.\nIn Kotlin, this can be represented as a data class User with a name property.\ndata class User(val name: String) However, this class can’t be used just yet for serialization purposes as we haven’t told the compiler to generate serialization code. This is where @Serializable annotation comes to use. This annotation instructs the compiler to generate code required for performing serialization for our class.\n@Serializable data class User(val name: String) That it! It’s as simple as that. Now the compiler can understand and serialize User objects.\nNext, we need to define JSON format behaviour we’re trying to pass. We do this by specifying a Json instance. From the docs, this class is\nThe main entry point to work with JSON serialization. It is typically used by constructing an application-specific instance, with configured json-specific behaviour. We’ll also need to defined what type of JSON we’re expecting. We define this using JsonConfiguration. This class helps us configure the behaviour for Json object. We’ll discuss more about this class a later, but for now, it’s good to know that it provides two ready to use configurations for us to use — Stable and Default. We’ll use the Stable configuration, which adheres to the JSON specification restriction and is provided by the runtime library.\nNow that we’ve gathered information about what we need, we can take a look at code to serialize the JSON to an object. It’s as simple as calling parse on the Json instance we have created. You have to pass the serializer and the JSON you want to parse.\nJson(JsonConfiguration.Stable) .parse(User.serializer(), \u0026#34;\u0026#34;\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;Gurpreet\u0026#34;}\u0026#34;\u0026#34;\u0026#34;)// Output: // User(\u0026#34;Gurpreet\u0026#34;) The above code reads “Parse this input JSON to a User object using the serializer provided. The JSON provided to the parse is ‘stable’ i.e., adheres to the standards”.\n2. Convert Kotlin object to JSON To deserialize an object (i.e. to convert it to JSON), stringify method can be used. Unlike parse, this method takes the kotlin object to deserialize as an argument.\nThe following code snippet shows how we can convert User object to JSON.\nJson(JsonConfiguration.Stable) .stringify(User.serializer(), User(\u0026#34;Gurpreet\u0026#34;))// Output: // {\u0026#34;name\u0026#34;:\u0026#34;Gurpreet\u0026#34;} 3. Parsing an object containing a list of objects Let’s say you have to parse a list of contacts instead of a single object and the JSON looks something like\nval jsonToParse = \u0026#34;\u0026#34;\u0026#34;{ \u0026#34;result\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Contact 2\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Contact 3\u0026#34; } ] }\u0026#34;\u0026#34;\u0026#34; Looking at the structure, we can infer that we need an object which contains a list of User objects. We define it as follows:\n@Serializable data class User(val name: String)@Serializable data class Contacts(val result: List\u0026lt;User\u0026gt;) Notice that we’ve marked both the classes as @Serializable. If we don’t mark User as @Serializable, the compiler will report an error which says Serializer has not been found for type \u0026lsquo;User’, essentially meaning that it doesn’t know how to serialize the type.\nIt’s pretty straight-forward from here. We need to serialize the JSON to Contactsobject, similar to how we parsed a User object before\nJson(JsonConfiguration.Stable) .parse(Contacts.serializer(), jsonToParse) // Output: // Contacts(listOf( // User(\u0026#34;Contact 1\u0026#34;), // User(\u0026#34;Contact 2\u0026#34;), // User(\u0026#34;Contact 3\u0026#34;) // )) Note that you can obtain the JSON back by using stringify in this case too.\n4. Parsing a list of objects If you noticed, all the types we have talked about till now are user defined types. We learnt about how to serialize and deserialize them. But what about the cases where we want to operate on a collection of objects, for example, a list of Users? We can’t apply @Serializable on a class we don’t own 🤷‍♂.\nFor this, the team at Jetbrains has got us covered 🎊. Serializers to parse widely used collections — Lists, Maps and Sets — are provided by the runtime library out of the box . To parse a list of contacts as shown below, we can use ListSerializer. All we need to do is tell what type of objects the list comprises of, which is User in our case.\nval listOfContacts = \u0026#34;\u0026#34;\u0026#34;[ { \u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Contact 2\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Contact 3\u0026#34; } ]\u0026#34;\u0026#34;\u0026#34; To serialize the JSON, we do\nJson(JsonConfiguration.Stable) .parse( ListSerializer(User.serializer()), listOfContacts ) // Output: // listOf( // User(\u0026#34;Contact 1\u0026#34;), // User(\u0026#34;Contact 2\u0026#34;), // User(\u0026#34;Contact 3\u0026#34;) // ) Similarly, we can deserialize the list to JSON by\nJson(JsonConfiguration.Stable) .stringify( ListSerializer(User.serializer()), listOf( User(\u0026#34;Contact 1\u0026#34;), User(\u0026#34;Contact 2\u0026#34;), User(\u0026#34;Contact 3\u0026#34;) ) ) // Output: // [{\u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;Contact 2\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;Contact 3\u0026#34;}] You can also serialize Maps by using MapSerializerand Sets by using SetSerializer in a similar way.\nHope this was helpful and you learnt something new. You can read the continuation article to this which talks about handling optional and transient properties.\nThis article is first of a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned, stay inside and keep reading!\nHope it helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cbr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/banner-kotlin-mobile.webp\"\n  alt=\"Header\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e\n\n\n\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization\" target=\"_blank\" rel=\"noopener\"\u003eKotlin serialization\u003c/a\u003e is kotlin-first, compile-time, type-safe, reflection-free and completely multi-platform ready \n\n\n\u003ca href=\"https://en.wikipedia.org/wiki/Serialization\" target=\"_blank\" rel=\"noopener\"\u003eserialization\u003c/a\u003e mechanism to convert kotlin objects into data formats like JSON or Protobuf and vice-versa.\nIt is comprised of a compiler plugin which is used to generate code for serializable classes and a runtime library, containing core classes and primitives for serialization \u0026amp; IO, among some other things.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlinx-serialization/kotlinx-serialization-current-structure.webp\"\n  alt=\"current-library-runtime-structure\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cdiv style=\"text-align:center;\"\u003eKotlinx serialization runtime project structure\u003c/div\u003e\n\u003cbr/\u003e\n\u003cp\u003eWhile JSON format is supported out of the box by the library, there’s first-class support for other formats like Protobuf \u0026amp; CBOR, with the option to extend the functionality by writing your own library to support any other format.\u003c/p\u003e\n\u003cp\u003eThe effort was \n\n\n\u003ca href=\"https://discuss.kotlinlang.org/t/kotlin-serialization/2063\" target=\"_blank\" rel=\"noopener\"\u003efirst announced\u003c/a\u003e in October 2016, where \n\n\n\u003ca href=\"https://x.com/elizarov\" target=\"_blank\" rel=\"noopener\"\u003e@elizarov\u003c/a\u003e posted about the team’s efforts on “working on a generic Kotlin Serialization facility for some future release of Kotlin”. You can know more about the design, goals and core concepts of kotlin serialization by going through \n\n\n\u003ca href=\"https://github.com/Kotlin/KEEP/blob/serialization/proposals/extensions/serialization.md\" target=\"_blank\" rel=\"noopener\"\u003ethis KEEP\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"why\"\u003eWhy?\u003c/h3\u003e\n\u003cp\u003eCode sharing between platforms isn’t easy. Each platform you want to support has different ways of handling different things — IO, transformations, threading, serialization to name a few. There already are various libraries out there which support kotlin serialization, even generate kotlin code if you want to, Square’s Moshi being probably being the most famous one.\u003c/p\u003e\n\u003cp\u003eHowever, all of these work only on JVM and don’t support other platforms. That’s why a new mechanism is required — one that supports all the platforms.\u003c/p\u003e\n\u003ch3 id=\"setup\"\u003eSetup\u003c/h3\u003e\n\u003cp\u003ePlease refer to the official guide to setup. It’s simple, all you’ll need to do is :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eApply the serialization plugin, and\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAdd dependency on the runtime library in your build.gradle file.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eYou’ll need to be on Kotlin version 1.3.70 or higher to use runtime library version 0.20.0, which is the latest release at time of writing this article.\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"learning-by-examples\"\u003eLearning by examples\u003c/h2\u003e\n\u003cp\u003e(You can see all these examples as a series of unit tests here in \n\n\n\u003ca href=\"https://gist.github.com/GurpreetSK95/d227315561c470f12f488f03ec0007a9\" target=\"_blank\" rel=\"noopener\"\u003ethis gist\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eLet’s go through some of the basic cases you’re likely to encounter if you plan on using kotlin serialization in one of your projects.\u003c/p\u003e\n\u003ch3 id=\"1-parse-json-object-to-kotlin-object\"\u003e1. Parse JSON object to Kotlin object\u003c/h3\u003e\n\u003cp\u003eSuppose you want to convert a JSON object to a kotlin object. For this, you’ll need to specify two things:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe object to which you’re trying to parse the JSON to, and\u003c/li\u003e\n\u003cli\u003eThe behaviour of the JSON format you’re trying to parse\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet’s say we want to parse JSON containing user’s information — just his name for now. The JSON looks like \u003ccode\u003e{“name”: “Gurpreet”}\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn Kotlin, this can be represented as a data class User with a name property.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edata class User(val name: String)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, this class can’t be used just yet for serialization purposes as we haven’t told the compiler to generate serialization code. This is where @Serializable annotation comes to use. This annotation instructs the compiler to generate code required for performing serialization for our class.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#1e66f5;font-weight:bold\"\u003e@Serializable\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e(\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003ename\u003c/span\u003e: String)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThat it! It’s as simple as that. Now the compiler can understand and serialize User objects.\u003c/p\u003e\n\u003cp\u003eNext, we need to define JSON format behaviour we’re trying to pass. We do this by specifying a Json instance. From the docs, this class is\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eThe main entry point to work with JSON serialization\u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eIt is typically used by constructing an application\u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e-\u003c/span\u003especific instance, with configured json\u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e-\u003c/span\u003especific behaviour\u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe’ll also need to defined what type of JSON we’re expecting. We define this using JsonConfiguration. This class helps us configure the behaviour for Json object. We’ll discuss more about this class a later, but for now, it’s good to know that it provides two ready to use configurations for us to use — Stable and Default. We’ll use the Stable configuration, which adheres to the \n\n\n\u003ca href=\"https://www.ietf.org/rfc/rfc4627.txt\" target=\"_blank\" rel=\"noopener\"\u003eJSON specification restriction\u003c/a\u003e and is provided by the runtime library.\u003c/p\u003e\n\u003cp\u003eNow that we’ve gathered information about what we need, we can take a look at code to serialize the JSON to an object. It’s as simple as calling parse on the Json instance we have created. You have to pass the serializer and the JSON you want to parse.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJson(\u003cspan style=\"color:#df8e1d\"\u003eJsonConfiguration\u003c/span\u003e.Stable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .parse(\u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e.serializer(), \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;\u0026#34;\u0026#34;{\u0026#34;name\u0026#34;: \u0026#34;Gurpreet\u0026#34;}\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e)\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Output:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// User(\u0026#34;Gurpreet\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe above code reads \u003cem\u003e“Parse this input JSON to a User object using the serializer provided. The JSON provided to the parse is ‘stable’ i.e., adheres to the standards”\u003c/em\u003e.\u003c/p\u003e\n\u003ch4 id=\"2-convert-kotlin-object-to-json\"\u003e2. Convert Kotlin object to JSON\u003c/h4\u003e\n\u003cp\u003eTo deserialize an object (i.e. to convert it to JSON), stringify method can be used. Unlike parse, this method takes the kotlin object to deserialize as an argument.\u003c/p\u003e\n\u003cp\u003eThe following code snippet shows how we can convert User object to JSON.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJson(\u003cspan style=\"color:#df8e1d\"\u003eJsonConfiguration\u003c/span\u003e.Stable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .stringify(\u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e.serializer(), User(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Gurpreet\u0026#34;\u003c/span\u003e))\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Output:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// {\u0026#34;name\u0026#34;:\u0026#34;Gurpreet\u0026#34;}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"3-parsing-an-object-containing-a-list-of-objects\"\u003e3. Parsing an object containing a list of objects\u003c/h3\u003e\n\u003cp\u003eLet’s say you have to parse a list of contacts instead of a single object and the JSON looks something like\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003ejsonToParse\u003c/span\u003e = \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;\u0026#34;\u0026#34;{\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  \u0026#34;result\u0026#34;: [\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e      \u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e      \u0026#34;name\u0026#34;: \u0026#34;Contact 2\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e      \u0026#34;name\u0026#34;: \u0026#34;Contact 3\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  ]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e}\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLooking at the structure, we can infer that we need an object which contains a list of User objects. We define it as follows:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#1e66f5;font-weight:bold\"\u003e@Serializable\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e(\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003ename\u003c/span\u003e: String)\u003cspan style=\"color:#1e66f5;font-weight:bold\"\u003e@Serializable\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eContacts\u003c/span\u003e(\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eresult\u003c/span\u003e: List\u0026lt;User\u0026gt;)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNotice that we’ve marked both the classes as @Serializable. If we don’t mark User as @Serializable, the compiler will report an error which says Serializer has not been found for type \u0026lsquo;User’, essentially meaning that it doesn’t know how to serialize the type.\u003c/p\u003e\n\u003cp\u003eIt’s pretty straight-forward from here. We need to serialize the JSON to Contactsobject, similar to how we parsed a User object before\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJson(\u003cspan style=\"color:#df8e1d\"\u003eJsonConfiguration\u003c/span\u003e.Stable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .parse(\u003cspan style=\"color:#df8e1d\"\u003eContacts\u003c/span\u003e.serializer(), jsonToParse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Output:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Contacts(listOf(\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//    User(\u0026#34;Contact 1\u0026#34;),\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//    User(\u0026#34;Contact 2\u0026#34;),\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//    User(\u0026#34;Contact 3\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// ))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote that you can obtain the JSON back by using stringify in this case too.\u003c/p\u003e\n\u003ch3 id=\"4-parsing-a-list-of-objects\"\u003e4. Parsing a list of objects\u003c/h3\u003e\n\u003cp\u003eIf you noticed, all the types we have talked about till now are user defined types. We learnt about how to serialize and deserialize them. But what about the cases where we want to operate on a collection of objects, for example, a list of Users? We can’t apply @Serializable on a class we don’t own 🤷‍♂.\u003c/p\u003e\n\u003cp\u003eFor this, the team at Jetbrains has got us covered 🎊. Serializers to parse widely used collections — Lists, Maps and Sets — are provided by the runtime library out of the box . To parse a list of contacts as shown below, we can use ListSerializer. All we need to do is tell what type of objects the list comprises of, which is User in our case.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003elistOfContacts\u003c/span\u003e = \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;\u0026#34;\u0026#34;[\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    \u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    \u0026#34;name\u0026#34;: \u0026#34;Contact 2\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e    \u0026#34;name\u0026#34;: \u0026#34;Contact 3\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#40a02b\"\u003e]\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo serialize the JSON, we do\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJson(\u003cspan style=\"color:#df8e1d\"\u003eJsonConfiguration\u003c/span\u003e.Stable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .parse(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ListSerializer(\u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e.serializer()),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        listOfContacts\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Output:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// listOf(\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//   User(\u0026#34;Contact 1\u0026#34;),\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//   User(\u0026#34;Contact 2\u0026#34;),\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e//   User(\u0026#34;Contact 3\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// )\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSimilarly, we can deserialize the list to JSON by\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJson(\u003cspan style=\"color:#df8e1d\"\u003eJsonConfiguration\u003c/span\u003e.Stable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    .stringify(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ListSerializer(\u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e.serializer()),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        listOf(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            User(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Contact 1\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            User(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Contact 2\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            User(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Contact 3\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Output:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// [{\u0026#34;name\u0026#34;: \u0026#34;Contact 1\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;Contact 2\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;Contact 3\u0026#34;}]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYou can also serialize Maps by using MapSerializerand Sets by using SetSerializer in a similar way.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eHope this was helpful and you learnt something new. You can read \n\n\n\n      \n    \n  \u003ca href=\"/posts/kotlinx-serialization-optional-and-transient-properties/\"\u003ethe continuation article\u003c/a\u003e to this which talks about handling optional and transient properties.\u003c/p\u003e\n\u003cp\u003eThis article is first of a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned, stay inside and keep reading!\u003c/p\u003e\n\u003cp\u003eHope it helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/getting-started-with-kotlin-serialization-3315c59bafb2\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlinx-serialization-getting-started/",
      "date_published": "3056-03-09T523:33:00+05:30",
      "date_modified": "3056-03-09T523:33:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "0a66143805ea3ce807d3705af88b1d2f7d60a22d",
      "title": "Kotlinx Serialization - optional and transient properties",
      "summary": "",
      "content_text": "When interacting with a Rest API, it’s common to have some optional properties in the response. These properties might or might not be present at runtime. Let’s consider we updated out User data object to contain a required, non-nullable and unique id and age, which is an optional, nullable property.\n@Serializable data class User( val id: String, val name: String, val age: Int? = null ) (You can see all these examples as a series of unit tests here in this gist.)\nHandling optional values Kotlin’s features — especially its nullable types and default parameter values prove to be great when dealing with JSON. You don’t need to do anything special to handle optional values when working with Kotlin serialization.\nAll properties with default values are considered optional.\nIn our case, age is an optional property with null as its default value. the property will be serialized if it’s found in JSON, else the serialized object will have age as null, unlike for required objects where a MissingFieldException is thrown.\nHandling Transient values Transient properties are those which you never want to take part in the entire serialization process. An example can be adding an isAdult property to our User object. The value is calculated on client side and will never be returned by the Rest API, hence it never needs to take part in the entire process.\nSuch properties can be marked using @Transient annotation. From the docs:\nMarking a property Transient makes it invisible for whole serialization framework.\nThis also means that transient properties must have default values, as they can’t be initialized otherwise.\nThat’s all for this one folks! Hope this was helpful and you learnt something new.\nThis article is second of a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned, stay inside and keep reading!\nHope it helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cp\u003eWhen interacting with a Rest API, it’s common to have some optional properties in the response. These properties might or might not be present at runtime. Let’s consider we updated out User data object to contain a required, non-nullable and unique id and age, which is an optional, nullable property.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#1e66f5;font-weight:bold\"\u003e@Serializable\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eUser\u003c/span\u003e(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eid\u003c/span\u003e: String,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003ename\u003c/span\u003e: String,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eage\u003c/span\u003e: Int? = \u003cspan style=\"color:#8839ef\"\u003enull\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(You can see all these examples as a series of unit tests here in \n\n\n\u003ca href=\"https://gist.github.com/GurpreetSK95/f2752ac9984cb6fc122765762fc8df31\" target=\"_blank\" rel=\"noopener\"\u003ethis gist\u003c/a\u003e.)\u003c/p\u003e\n\u003ch4 id=\"handling-optional-values\"\u003eHandling optional values\u003c/h4\u003e\n\u003cp\u003eKotlin’s features — especially its nullable types and default parameter values prove to be great when dealing with JSON. You don’t need to do anything special to handle optional values when working with Kotlin serialization.\u003c/p\u003e\n\u003cp\u003eAll properties with default values are considered optional.\u003c/p\u003e\n\u003cp\u003eIn our case, age is an optional property with null as its default value. the property will be serialized if it’s found in JSON, else the serialized object will have age as null, unlike for required objects where a MissingFieldException is thrown.\u003c/p\u003e\n\u003ch4 id=\"handling-transient-values\"\u003eHandling Transient values\u003c/h4\u003e\n\u003cp\u003eTransient properties are those which you never want to take part in the entire serialization process. An example can be adding an isAdult property to our User object. The value is calculated on client side and will never be returned by the Rest API, hence it never needs to take part in the entire process.\u003c/p\u003e\n\u003cp\u003eSuch properties can be marked using @Transient annotation. From the docs:\u003c/p\u003e\n\u003cp\u003eMarking a property Transient makes it invisible for whole serialization framework.\u003c/p\u003e\n\u003cp\u003eThis also means that transient properties must have default values, as they can’t be initialized otherwise.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eThat’s all for this one folks! Hope this was helpful and you learnt something new.\u003c/p\u003e\n\u003cp\u003eThis article is second of a series of articles I’m writing on Kotlin serialization while also learning more about the same. Stay tuned, stay inside and keep reading!\u003c/p\u003e\n\u003cp\u003eHope it helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/kotlin-serialization-optional-and-transient-properties-b3da3247e112\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlinx-serialization-optional-and-transient-properties/",
      "date_published": "3056-03-09T523:33:00+05:30",
      "date_modified": "3056-03-09T523:33:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "5576dfc76bc65cddc5f3b5a3b21d029934dcfff2",
      "title": "Multi-caret in Android Studio",
      "summary": "",
      "content_text": "Knowing keyboard shortcuts is important. They save you time and help you achieve more in less time. If you need convincing, I highly recommend watching ‘Mouseless Driven Development’ by Hadi Hariri.\nThis blog post is about one such feature of Android Studio (or any JetBrains IDE for that matter) which not a lot of people know about — multi-caret selection. A lot of my friends and colleagues who I pair-program with feel amazed by it and always ask “What was that!?”, so I decided to write about it to help them and everyone out there know about these.\nWhy use it? Because sometimes you need to replace just a few instances of a word/pattern and find \u0026amp; replace is not very useful.\nAlt + J / Control + G (Select next occurrence) Select next occurrence of the currently selected text. If no text is selected, the current word with cursor is selected.\nAlt + Shift + J / Control +Shift + G (Unselect current occurrence) Unselect current occurrence of selected text.\nAlt + Shift + Ctrl + J / Control + Command + G (Select all occurrences) Select all occurrences of the word in current file\nAlt + click \u0026amp; scroll / Option + click \u0026amp; scroll (Multiple cursors in column) Select a column of text in current file\nAlt + Shift + clicks / Option + Shift + clicks (Spawn caret at click position) Spawn carets across file at click position, even in the same word.\nHope it helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cp\u003eKnowing keyboard shortcuts is important. They save you time and help you achieve more in less time. If you need convincing, I highly recommend watching \n\n\n\u003ca href=\"https://vimeo.com/98922030\" target=\"_blank\" rel=\"noopener\"\u003e‘Mouseless Driven Development’ by Hadi Hariri\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis blog post is about one such feature of Android Studio (or any JetBrains IDE for that matter) which not a lot of people know about — multi-caret selection. A lot of my friends and colleagues who I pair-program with feel amazed by it and always ask “What was that!?”, so I decided to write about it to help them and everyone out there know about these.\u003c/p\u003e\n\u003cp\u003eWhy use it? Because sometimes you need to replace just a few instances of a word/pattern and find \u0026amp; replace is not very useful.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/shortcuts.webp\"\n  alt=\"Shortcuts\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"alt--j--control--g-select-next-occurrence\"\u003eAlt + J / Control + G (Select next occurrence)\u003c/h3\u003e\n\u003cp\u003eSelect next occurrence of the currently selected text. If no text is selected, the current word with cursor is selected.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/select-next-occurrence.gif\"\n  alt=\"Select-next-occurrence\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"alt--shift--j--control-shift--g-unselect-current-occurrence\"\u003eAlt + Shift + J / Control +Shift + G (Unselect current occurrence)\u003c/h3\u003e\n\u003cp\u003eUnselect current occurrence of selected text.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/unselect-current-occurrence.gif\"\n  alt=\"unselect-current-occurrence\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"alt--shift--ctrl--j--control--command--g-select-all-occurrences\"\u003eAlt + Shift + Ctrl + J / Control + Command + G (Select all occurrences)\u003c/h3\u003e\n\u003cp\u003eSelect all occurrences of the word in current file\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/select-all-occurrences.gif\"\n  alt=\"Select-all-occurrence\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"alt--click--scroll--option--click--scroll-multiple-cursors-in-column\"\u003eAlt + click \u0026amp; scroll / Option + click \u0026amp; scroll (Multiple cursors in column)\u003c/h3\u003e\n\u003cp\u003eSelect a column of text in current file\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/multiple-cursors-in-column.gif\"\n  alt=\"multiple-cursors-in-column\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"alt--shift--clicks--option--shift--clicks-spawn-caret-at-click-position\"\u003eAlt + Shift + clicks / Option + Shift + clicks (Spawn caret at click position)\u003c/h3\u003e\n\u003cp\u003eSpawn carets across file at click position, even in the same word.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/multi-caret-in-android-studio/caret-at-click-position.gif\"\n  alt=\"caret-at-click-position\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eHope it helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/multi-caret-in-android-studio-ef9fe83f1758\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/multi-caret-in-android-studio/",
      "date_published": "8066-08-09T623:88:00+05:30",
      "date_modified": "8066-08-09T623:88:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "d0f6dd196edf3eeb8a9e40df4c965f2434361bbd",
      "title": "Kotlin Sequences",
      "summary": "",
      "content_text": "Transforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.\nAlong with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.\nSequences are a collection of possibly infinite data, ordered in a certain way. Sequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.\nLooking at the source, it’s pretty clear that the Sequence interface is similar to Iterable in definition:\npublic interface Sequence\u0026lt;out T\u0026gt; { operator fun iterator(): Iterator\u0026lt;T\u0026gt; } public interface Iterable\u0026lt;out T\u0026gt; { operator fun iterator(): Iterator\u0026lt;T\u0026gt; } Sequences maintain the same API as collections. The difference comes in the way they are implemented. Let’s take an example to understand.\nLet’s suppose we have a list of customers, and each customer has a recorded unique id, first name, last name and age.\nprivate const val UNDEFINED = -1 data class Customer( val firstName: String, val lastName: String? = null, val age: Int = UNDEFINED ) Next, let’s define some data to demonstrate:\nprivate fun getCustomers(): List\u0026lt;Customer\u0026gt; { return listOf( Customer(\u0026#34;Ragunath\u0026#34;, \u0026#34;Jawahar\u0026#34;, 31), Customer(\u0026#34;Dinesh\u0026#34;, \u0026#34;Raja\u0026#34;, 28), Customer(\u0026#34;Donn\u0026#34;, \u0026#34;Felker\u0026#34;, 42), Customer(\u0026#34;RMK\u0026#34;, \u0026#34;\u0026#34;), Customer(\u0026#34;Omar\u0026#34;) ) } Now that we’re done with the basic setup, let’s define the problem statement. Let’s say we need to get the first names of all the customers whose age is not UNDEFINED and whose last name isn’t null. We can do this using the filter and map operators provided by the Collections API:\nfun main(args: Array\u0026lt;String\u0026gt;) { val result = getCustomers() .filter { it.lastName != null } .filter { it.age != UNDEFINED } .find { it.age == 31 } println(result) } Here, we first filter the customers whose last name is null, then filter customers whose age is UNDEFINED. Finally, we map the remaining customers’ first name and collect them in a list. If you run the above example, the output would be as expected:\nCustomer(firstName=Ragunath, lastName=Jawahar, age=31) But what were the operations leading to this output? If we put an onEach operator after each operation and print the value input to the function, the output would be something on the lines of:\nfilter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31) filter lastName: Customer(firstName=Dinesh, lastName=Raja, age=28) filter lastName: Customer(firstName=Donn, lastName=Felker, age=42) filter lastName: Customer(firstName=RMK, lastName=, age=0)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31) filter age: Customer(firstName=Dinesh, lastName=Raja, age=28) filter age: Customer(firstName=Donn, lastName=Felker, age=42)Customer(firstName=Ragunath, lastName=Jawahar, age=31) The result above shows Eager evaluation. The filter operation is applied on the entire collection (input), and an intermediate collection is formed. This intermediate collection is then passed down the chain to the next filter, which repeats the process and passes another collection to the find function, which returns the result.\nThis approach has two drawbacks:\nCreation of varying number of intermediate collections, depending on the number of operations to be performed, and Processing of all elements in the collection, even if it is not required. This hardly makes any difference in this tiny example, or even for any relatively larger use case for that matter (thanks to judicious use of inlined functions in stdlib and good garbage collection support by JVM),\nBut think about a case where the input data is in order of Millions, or virtually infinite? Wouldn’t it be nice if we could compute on data one after another, and bail as soon as the required condition is met?\nThis is exactly what sequences do! Here’s what the code above would look like when using sequences:\nfun main(args: Array\u0026lt;String\u0026gt;) { val result = getCustomers() .asSequence() // Creating a sequence .filter { it.lastName != null } .filter { it.age != UNDEFINED } .find { it.age == 31 } // Terminal operation println(result) } We create a sequence by wrapping the existing collection, and returning its elements when being iterated. If we apply the onEach function here and check the output, it’ll look like\nfilter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31)Customer(firstName=Ragunath, lastName=Jawahar, age=31) Once a terminal operation is encountered, computations are carried out one after another, and as soon as a result is found, execution is stopped. This is why sequences are called lazy.\nA visual comparison of how collections and sequences work can be:\nYou might have noticed the term ‘Terminal’ operation. If we remove it, no computation will be carried out. This is because operations on a sequence are divided into two categories: Intermediate and Terminal.\nIntermediate operations return a sequence which knows how to transform elements of the original sequence. These operations are always lazy, and are postponed until a terminal operation is performed. The terminal operation performs all the postponed operations and returns a some value as a result.\ngetCustomers() .asSequence() // Creating a sequence .filter { it.lastName != null } // Intermediate operation .filter { it.age != UNDEFINED } // Intermediate operation .find { it.age == 31 } // Terminal operation “Okay, this looks interesting. Let’s use sequences EVERYWHERE!”.\nNope. Please don’t.\nAs a rule of thumb, a sequence should be used at places where a chain of operations are being performed on a very large (or possibly infinite) collection of data, and/or there is a need to break out of the computation as soon as an element matching the predicate is found. As mentioned earlier, eager operations on regular collections are highly optimised and efficient in kotlin and should fare you well for most cases.\nAnother thing to remember is that the elements of a sequence cannot be accessed as simply as elements of a collection. For example, the following snippet will produce a compile-time error:\nfun main() { val sequence = (1..10) .asSequence() .map { it * 3 } println(sequence[1]) // Error: Unresolved Reference. None of the following candidate is applicable because of receiver type mismatch. } This is because the accessed element might not have been processed at all! (remember lazy evaluation for sequences?)\nHope this helps!\nOriginally posted on Medium link\n",
      "content_html": "\u003cp\u003eTransforming, filtering, manipulating and operating on data is what every developer does almost every day at their jobs. If you’re using Kotlin for writing your applications, you might have used map or filter operator to transform a collection from one form to another.\u003c/p\u003e\n\u003cp\u003eAlong with the kotlin.collections package, Kotlin also provides a way to lazily represent and evaluate a collection of data. This is accomplished using Sequences.\u003c/p\u003e\n\u003ch3 id=\"sequences-are-a-collection-of-possibly-infinite-data-ordered-in-a-certain-way\"\u003e\u003cem\u003eSequences are a collection of possibly infinite data, ordered in a certain way.\u003c/em\u003e\u003c/h3\u003e\n\u003cp\u003eSequences are a part of the language standard library and allow lazy evaluation of large amount of data (in millions), as opposed to collections, which compute and evaluate operations on a data set eagerly.\u003c/p\u003e\n\u003cp\u003eLooking at the source, it’s pretty clear that the Sequence interface is similar to Iterable in definition:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eSequence\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#8839ef\"\u003eout\u003c/span\u003e T\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#8839ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003eiterator\u003c/span\u003e(): Iterator\u0026lt;T\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eIterable\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#8839ef\"\u003eout\u003c/span\u003e T\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#8839ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003eiterator\u003c/span\u003e(): Iterator\u0026lt;T\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSequences maintain the same API as collections. The difference comes in the way they are implemented. Let’s take an example to understand.\u003c/p\u003e\n\u003cp\u003eLet’s suppose we have a list of customers, and each customer has a recorded unique id, first name, last name and age.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eUNDEFINED\u003c/span\u003e = -\u003cspan style=\"color:#fe640b\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003edata\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#df8e1d\"\u003eCustomer\u003c/span\u003e(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003efirstName\u003c/span\u003e: String,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003elastName\u003c/span\u003e: String? = \u003cspan style=\"color:#8839ef\"\u003enull\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eage\u003c/span\u003e: Int = UNDEFINED\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNext, let’s define some data to demonstrate:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003egetCustomers\u003c/span\u003e(): List\u0026lt;Customer\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#8839ef\"\u003ereturn\u003c/span\u003e listOf(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Customer(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Ragunath\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Jawahar\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#fe640b\"\u003e31\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Customer(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Dinesh\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Raja\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#fe640b\"\u003e28\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Customer(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Donn\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Felker\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#fe640b\"\u003e42\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Customer(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;RMK\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#40a02b\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      Customer(\u003cspan style=\"color:#40a02b\"\u003e\u0026#34;Omar\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow that we’re done with the basic setup, let’s define the problem statement. Let’s say we need to get the first names of all the customers whose age is not UNDEFINED and whose last name isn’t null. We can do this using the filter and map operators provided by the Collections API:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003emain\u003c/span\u003e(args: Array\u0026lt;String\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eresult\u003c/span\u003e = getCustomers()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.lastName \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003enull\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e UNDEFINED }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .find   { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003e31\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  println(result)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere, we first filter the customers whose last name is null, then filter customers whose age is UNDEFINED. Finally, we map the remaining customers’ first name and collect them in a list. If you run the above example, the output would be as expected:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eCustomer(firstName=Ragunath, lastName=Jawahar, age=\u003cspan style=\"color:#fe640b\"\u003e31\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut what were the operations leading to this output? If we put an onEach operator after each operation and print the value input to the function, the output would be something on the lines of:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter lastName: Customer(firstName=Dinesh, lastName=Raja, age=28)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter lastName: Customer(firstName=Donn, lastName=Felker, age=42)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter lastName: Customer(firstName=RMK, lastName=, age=0)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter age: Customer(firstName=Dinesh, lastName=Raja, age=28)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter age: Customer(firstName=Donn, lastName=Felker, age=42)Customer(firstName=Ragunath, lastName=Jawahar, age=31)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe result above shows Eager evaluation. The filter operation is applied on the entire collection (input), and an intermediate collection is formed. This intermediate collection is then passed down the chain to the next filter, which repeats the process and passes another collection to the find function, which returns the result.\u003c/p\u003e\n\u003cp\u003eThis approach has two drawbacks:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCreation of varying number of intermediate collections, depending on the number of operations to be performed, and\u003c/li\u003e\n\u003cli\u003eProcessing of all elements in the collection, even if it is not required.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis hardly makes any difference in this tiny example, or even for any relatively larger use case for that matter (thanks to judicious use of inlined functions in stdlib and good garbage collection support by JVM),\u003c/p\u003e\n\u003cp\u003eBut think about a case where the input data is in order of Millions, or virtually infinite? Wouldn’t it be nice if we could compute on data one after another, and bail as soon as the required condition is met?\u003c/p\u003e\n\u003cp\u003eThis is exactly what sequences do! Here’s what the code above would look like when using sequences:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003emain\u003c/span\u003e(args: Array\u0026lt;String\u0026gt;) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003eresult\u003c/span\u003e = getCustomers()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .asSequence() \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Creating a sequence\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.lastName \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003enull\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e UNDEFINED }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .find   { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003e31\u003c/span\u003e } \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Terminal operation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  println(result)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe create a sequence by wrapping the existing collection, and returning its elements when being iterated. If we apply the onEach function here and check the output, it’ll look like\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efilter lastName: Customer(firstName=Ragunath, lastName=Jawahar, age=31)filter age: Customer(firstName=Ragunath, lastName=Jawahar, age=31)Customer(firstName=Ragunath, lastName=Jawahar, age=31)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOnce a terminal operation is encountered, computations are carried out one after another, and as soon as a result is found, execution is stopped. This is why sequences are called lazy.\u003c/p\u003e\n\u003cp\u003eA visual comparison of how collections and sequences work can be:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/assets/posts/kotlin-sequences-1.webp\"\n  alt=\"kotlin-sequences\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eYou might have noticed the term ‘Terminal’ operation. If we remove it, no computation will be carried out. This is because operations on a sequence are divided into two categories: Intermediate and Terminal.\u003c/p\u003e\n\u003cp\u003eIntermediate operations return a sequence which knows how to transform elements of the original sequence. These operations are always lazy, and are postponed until a terminal operation is performed. The terminal operation performs all the postponed operations and returns a some value as a result.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egetCustomers()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      .asSequence() \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Creating a sequence\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.lastName \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#8839ef\"\u003enull\u003c/span\u003e } \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Intermediate operation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e      .filter { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e!=\u003c/span\u003e UNDEFINED } \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Intermediate operation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e      .find   { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e.age \u003cspan style=\"color:#04a5e5;font-weight:bold\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003e31\u003c/span\u003e } \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Terminal operation\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003cp\u003e“Okay, this looks interesting. Let’s use sequences EVERYWHERE!”.\u003c/p\u003e\n\u003cp\u003eNope. Please don’t.\u003c/p\u003e\n\u003cp\u003eAs a rule of thumb, a sequence should be used at places where a chain of operations are being performed on a very large (or possibly infinite) collection of data, and/or there is a need to break out of the computation as soon as an element matching the predicate is found. As mentioned earlier, eager operations on regular collections are highly optimised and efficient in kotlin and should fare you well for most cases.\u003c/p\u003e\n\u003cp\u003eAnother thing to remember is that the elements of a sequence cannot be accessed as simply as elements of a collection. For example, the following snippet will produce a compile-time error:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8839ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#1e66f5\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#8839ef\"\u003eval\u003c/span\u003e \u003cspan style=\"color:#fe640b\"\u003esequence\u003c/span\u003e = (\u003cspan style=\"color:#fe640b\"\u003e1.\u003c/span\u003e.\u003cspan style=\"color:#fe640b\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     .asSequence()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     .map { \u003cspan style=\"color:#8839ef\"\u003eit\u003c/span\u003e * \u003cspan style=\"color:#fe640b\"\u003e3\u003c/span\u003e }    println(sequence[\u003cspan style=\"color:#fe640b\"\u003e1\u003c/span\u003e]) \u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e// Error: Unresolved Reference. None of the                                              following candidate is applicable because of receiver type mismatch.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#9ca0b0;font-style:italic\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis is because the accessed element might not have been processed at all! (remember lazy evaluation for sequences?)\u003c/p\u003e\n\u003cp\u003eHope this helps!\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/android-news/kotlin-sequences-ac6dc7c883d3\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/kotlin-sequences/",
      "date_published": "10036-10-09T323:1010:00+05:30",
      "date_modified": "10036-10-09T323:1010:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    },
    
    {
      "id": "391cf1b9ff8b522fbbe6da20c9064a587acdbc6a",
      "title": "Listening to Memory events using onTrimMemory() on Android",
      "summary": "",
      "content_text": "Anyone who has been developing android application knows how memory-scarce the platform is, with each application being provided with upto 24/32mb of memory (which can go to as low as 16mb for older devices). In such a scenario, it is the developer’s duty to look out for memory leaks and free any resources that are not been used by the application.\nOne way of managing memory in response to system events is the onTrimMemory() method. From the docs:\nonTrimMemory(): Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. This will happen for example when it goes in the background and there is not enough memory to keep as many background processes running as desired. Found in the ComponentsCallback2 interface, this method should be implemented to incrementally release memory based on current system constraints. This helps provide a more responsive system overall, and benefits the user experience for the application by allowing the system to keep the process alive longer.\nFor a better read on how to optimise the memory usage, do read the official docs, or show some love and I’ll post another article on Using More Memory-Efficient Code Constructs to create android applications. All kinds of feedback is welcome.\nReferences:\nMemory limits per app are here depending on screen size and Android version: https://drive.google.com/file/d/0B7Vx1OvzrLa3Y0R0X1BZbUpicGc/view https://stackoverflow.com/questions/19398827/understanding-ontrimmemory-int-level Originally posted on Medium link\n",
      "content_html": "\u003cp\u003eAnyone who has been developing android application knows how memory-scarce the platform is, with each application being provided with \n\n\n\u003ca href=\"https://stackoverflow.com/questions/18675557/what-is-the-maximum-amount-of-ram-an-app-can-use\" target=\"_blank\" rel=\"noopener\"\u003eupto 24/32mb of memory\u003c/a\u003e (which can go to as low as 16mb for older devices). In such a scenario, it is the developer’s duty to look out for memory leaks and free any resources that are not been used by the application.\u003c/p\u003e\n\u003cp\u003eOne way of managing memory in response to system events is the \n\n\n\u003ca href=\"https://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory%28int%29\" target=\"_blank\" rel=\"noopener\"\u003eonTrimMemory() method\u003c/a\u003e. From the docs:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#4c4f69;background-color:#eff1f5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eonTrimMemory():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eCalled when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eThis will happen for example when it goes in the background and there is not enough memory to keep as many background processes running as desired.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFound in the ComponentsCallback2 interface, this method should be implemented to incrementally release memory based on current system constraints. This helps provide a more responsive system overall, and benefits the user experience for the application by allowing the system to keep the process alive longer.\u003c/p\u003e\n\u003cp\u003eFor a better read on how to optimise the memory usage, do read the official docs, or show some love and I’ll post another article on Using More Memory-Efficient Code Constructs to create android applications. All kinds of feedback is welcome.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eReferences\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eMemory limits per app are here depending on screen size and Android version: \n\n\n\u003ca href=\"https://drive.google.com/file/d/0B7Vx1OvzrLa3Y0R0X1BZbUpicGc/view\" target=\"_blank\" rel=\"noopener\"\u003ehttps://drive.google.com/file/d/0B7Vx1OvzrLa3Y0R0X1BZbUpicGc/view\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\u003ca href=\"https://stackoverflow.com/questions/19398827/understanding-ontrimmemory-int-level\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackoverflow.com/questions/19398827/understanding-ontrimmemory-int-level\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cem\u003eOriginally posted on Medium \n\n\n\u003ca href=\"https://medium.com/@gurpreetsk/memory-management-on-android-using-ontrimmemory-f500d364bc1a\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n",
      "url": "https://imGurpreetSK.github.io/posts/listening-to-memory-events-using-ontrimmemory/",
      "date_published": "21086-21-09T88:2121:00+05:30",
      "date_modified": "21086-21-09T88:2121:00+05:30",
      "author": {
        "name": "Gurpreet",
        "url": "https://imGurpreetSK.github.io/"
      }
    }
    
  ]
}